<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0">
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.9.0/css/all.css" integrity="sha384-i1LQnF23gykqWXg6jxC2ZbCbUMxyw5gLZY6UiUS98LYV5unm8GWmfkIS6jqJfb4E" crossorigin="anonymous">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <style>
      .card-custom {
        height: 650px;
        width: 100%;
      }
      .card-custom > div {
        height: inherit;
        width: inherit;
      }
      .map-custom {
        height: 100%;
        width: 100%;
      }
      #list-between {
        padding: 10px;
        border: solid 1px grey;
      }
      #map {
        height: 100%;
        width: 100%;
      }
      #infowindow-content {
        padding: 2px;
      }
      #btn-add-location {
        margin-bottom: 10px;
      }
      .form-custom {
        width: 100%;
        margin-bottom: 10px;
      }
      .form-complete-warning {
        font-size: 12px;
        margin-top: -5px;
        margin-bottom: 5px;
      }
      .form-limit-error {
        color: red;
        font-size: 12px;
        display: none;
      }
      html, body {
        height: 100%;
        margin: 0;
        padding: 20px;
      }
    </style>
  </head>
  <body>
    <div class="card card-custom">
      <div class="row no-gutters">
        <div class="col-md-4 bg-primary">
          <div class="card-body">
            <div id="form-container">
              <input id="form-autocomplete0" class="form-control form-custom form-complete" type="text"
              placeholder="Enter a location">
              <input id="form-autocomplete1" class="form-control form-custom form-complete" type="text"
              placeholder="Enter a location">
            </div>
            <div class="form-limit-error">Oops! You can't add more than 10 addresses.</div>
            <button id="btn-add-location" type="button">Add another location</button>
            <button id="btn-optimize-routes" type="button">Optimize route</button>
          </div>
        </div>
        <div class="col-md-8 map-custom">
          <div id="map"></div>
        </div>
      </div>
    </div>
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <script>
      apikey = "AIzaSyB48MFEadC8w1pS19p3se3P2rz7SzB641w";

      function initMap() {
        var map = new google.maps.Map(document.getElementById('map'), {
          center: {lat: -34.397, lng: 150.644},
          zoom: 8
        });

        var autocompletes = [];

        // Init autocomplete for form with id
        function activateFormAutocomplete(input) {
          var autocomplete =  new google.maps.places.Autocomplete(input);
          autocompletes.push(autocomplete);
          autocomplete.setFields(['formatted_address', 'geometry', 'icon', 'name', 'place_id']);

          // Init info window for autocomplete
          var infowindowContent = $('<div id="infowindow-content"><img src="" width="16" height="16" id="place-icon"><span id="place-name" class="card-title"></span><br><span id="place-address" class="card-subtitle"></span></div>');
          infowindowContent.insertAfter($(".card-custom"));
          infowindowContent = infowindowContent.get(0);
          var infowindow = new google.maps.InfoWindow();
          infowindow.setContent(infowindowContent);

          // Init marker (red pin) for autocomplete
          var marker = new google.maps.Marker({
            map: map
          });

          // Create dynamic input warning 
          var inputWarning = $('<div class="text-danger form-complete-warning"> No details available for input: <span></span></div>');
          inputWarning.insertAfter($("#" + input.id));
          inputWarning = inputWarning.get(0);
          inputWarning.style.display = "none";

          // Listener for input in autocomplete form (pressing ENTER or selecting an address)
          autocomplete.addListener('place_changed', function (){
            console.log("Place changed");
            infowindow.close();
            marker.setVisible(false);
            var place = autocomplete.getPlace();       
            console.log(place.name, place.place_id);     
            
            if (!place.geometry) {
              console.log("Place doesn't have geometry.");
              inputWarning.children[0].textContent = '"' + place.name + '"';
              inputWarning.style.display = "block";
            }
            else {
              console.log("Place has geometry.");
              $("#" + input.id).val(place.name);
              inputWarning.style.display = "none";
              map.setCenter(place.geometry.location);
              map.setZoom(17);
              marker.setPosition(place.geometry.location);
              marker.setVisible(true);
              infowindowContent.children['place-icon'].src = place.icon;
              infowindowContent.children['place-name'].textContent = place.name;
              infowindowContent.children['place-address'].textContent = place.formatted_address;
              infowindow.open(map, marker);
            }
          });
        }

        // Activate the first two autocomplete forms 
        activateFormAutocomplete(document.getElementById("form-autocomplete0"));
        activateFormAutocomplete(document.getElementById("form-autocomplete1"));

        // Listener to add additional autocomplete forms
        document.getElementById("btn-add-location").addEventListener("click", addFormAutocomplete);
     
        var formContainer = document.getElementById("form-container");

        // Creating forms with dynamic id for search autocomplete
        function addFormAutocomplete() {
          var input = document.createElement("input");
          input.type = "text";
          input.className = "form-control form-custom form-complete"; 
          var autocompleteForms = document.getElementsByClassName('form-complete');
          input.id = "form-autocomplete" + autocompleteForms.length.toString();
          formContainer.appendChild(input);
          activateFormAutocomplete(input);
        }

        document.getElementById("btn-optimize-routes").addEventListener("click", optimizeRoutes);

        function optimizeRoutes() {
          // Function associated with btn-optimize-routes

          class Location {
            constructor(parent, place){
              // g = distance between current node and start node
              // h = heuristic = exact distance between current node to end node
              // f = total cost of current node
              this.parent = parent;
              this.place = place;
              this.f = 0;
              this.g = 0;
              this.h = 0;
            }
            distanceBetween(node){
              var pt1 = this.place.geometry.location;
              var pt2 = node.place.geometry.location;
              var pt1Location = new google.maps.LatLng(pt1.lat(), pt1.lng());
              var pt2Location = new google.maps.LatLng(pt2.lat(), pt2.lng());
              var distance = google.maps.geometry.spherical.computeDistanceBetween(pt1Location, pt2Location);
              return distance;
            }
          } 

          locations = [];
          // Instantiate Location objects for each item in autocompletes (from line 88)
          for (var i = 0; i < autocompletes.length; i++){
            var place = autocompletes[i].getPlace();
            var location = new Location(null, place);
            locations.push(location);
          }

          function AstarSearch(){
            var originalLocationsLength = locations.length;
            var startLocation = locations.shift();
            var endLocation = locations[locations.length - 1];
            var visited = [];
            console.log("Is locations an array? " + Array.isArray(locations));
            var startNeighbors = popNeighbor(startLocation, locations);
            console.log("Is startNeighbors an array? " + Array.isArray(startNeighbors));
            console.log("startNeighbors length: " + startNeighbors.length);
            var optimizedEndLocations = search(startLocation, startNeighbors);
            console.log(optimizedEndLocations);
            var bestPath = getBestPath(optimizedEndLocations);
            console.log(bestPath);

            for (var i = 0; i < autocompletes.length; i++){
              var autocomplete = autocompletes[i];
              var location = bestPath[i];

              // Checking
              console.log(location.place);
              console.log(location.place.place_id);

              autocomplete.set("place", location.place);

              // Checking
              var place = autocomplete.getPlace();
              console.log(place === location.place);
              console.log(place.place_id == location.place.place_id);
              console.log(place.geometry);
              console.log(place.geometry == location.place.geometry);
            }
          
            function search(currentLocation, neighbors){
              // Returns list of endLocations(s)
              
              if (currentLocation.place.place_id == endLocation.place.place_id){
                if (validPath(currentLocation)){
                  console.log("[currentLocation] is an array: " + Array.isArray([currentLocation]));
                  return [currentLocation];
                }
                else{
                  return [];
                }
              }
              else{
                var endLocations = [];
                visited.push(currentLocation);
                console.log("Pushed " + currentLocation.place.name + " to visited");
                console.log("Neighbors length: " + neighbors.length);

                for (var i = 0; i < neighbors.length; i++){
                  var neighbor = neighbors[i];
                  var child = new Location(currentLocation, neighbor.place);
                  console.log("Child " + child.place.name +" with parent " + currentLocation.place.name + " in question: " + child);
                  console.log("Distance between parent " + currentLocation.place.name + " and child: " + child.place.name + ": " + child.distanceBetween(currentLocation));
                  child.g = currentLocation.g + child.distanceBetween(currentLocation);
                  child.h = child.distanceBetween(endLocation);
                  child.f = child.g + child.h;
                  console.log("g value of " + child.place.name + "from " + currentLocation.place.name + ": " + child.g);
                  console.log("h value of " + child.place.name + " to " + endLocation.place.name + ": " + child.h);
                  console.log("f value of " + child.place.name + ": " + child.f);
                  var newNeighbors = popNeighbor(child, neighbors);
                  var childEndLocations = search(child, newNeighbors);
                  console.log("Length of endLocations of parent " + currentLocation.place.name + ": " + endLocations.length);
                  console.log("childEndLocations: ",  childEndLocations);
                  console.log("childEndLocations is an array: " + Array.isArray(childEndLocations));
                  console.log("Length of childEndLocations: " + childEndLocations.length);
                  if (childEndLocations){
                    endLocations = endLocations.concat(childEndLocations);
                  }
                  console.log("Length of endLocations after concat: " + endLocations.length);
                }
                return endLocations;
              }
            }

            function validPath(currentLocation){
              // Returns whether or not path is valid
              console.log("Started validPath");
              var testPath = getPath(currentLocation);
              console.log("testPath length: " + testPath.length);
              console.log("originalLocationsLength: " + originalLocationsLength);
              if (testPath.length == originalLocationsLength){
                console.log("Path is valid!");
                return true;
              }
              return false;
            }

            function popNeighbor(location, neighbors){
              // Returns new list of neighbors without altering original neighbors
              var poppedNeighbors = neighbors.slice(0);
              for (var i = 0; i < neighbors.length; i++){
                var neighbor = neighbors[i];
                if (location.place.place_id == neighbor.place.place_id){
                  poppedNeighbors.splice(i, 1);
                }
              }
              return poppedNeighbors;
            }

            function getPath(location){
              // Returns path (list) by recursively going up parent levels
              var path = [];
              var current = location;
              while (current != null){
                path.push(current);
                current = current.parent;
              }
              path.reverse();
              return path;
            }

            function getBestPath(optimizedEndLocations){
              // Return path of optimized end node with the lowest f value
              console.log("getBestPath started");
              var lowest = optimizedEndLocations[0];
              console.log("First lowest: " + lowest);
              for (var i = 0; i < optimizedEndLocations.length; i++){
                var optimizedEndLocation = optimizedEndLocations[i];
                console.log(optimizedEndLocation);
                if (lowest.f > optimizedEndLocation.f){
                  lowest = optimizedEndLocation;
                }
              }
              var bestPath = getPath(lowest);
              return bestPath;
            }
          } // End of AstarSearch
          AstarSearch();
        } // End of optimizeRoutes
      } // End of initMap
    </script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB48MFEadC8w1pS19p3se3P2rz7SzB641w&libraries=places,geometry&callback=initMap"
    async defer></script>
  </body>
</html>